import os
import re
import argparse
import sys

# Regex patterns to capture the type definitions
# Capture groups: (ActualType, ShortName)
REGEX_VEC  = re.compile(r"DEFINE_VEC_TYPE\s*\(\s*(.+?)\s*,\s*(\w+)\s*\)")
REGEX_LIST = re.compile(r"DEFINE_LIST_TYPE\s*\(\s*(.+?)\s*,\s*(\w+)\s*\)")

# Capture groups: (KeyType, ValType, ShortName)
REGEX_MAP  = re.compile(r"DEFINE_MAP_TYPE\s*\(\s*(.+?)\s*,\s*(.+?)\s*,\s*(\w+)\s*\)")

def scan_directory(root_dir):
    # Sets to store unique tuples (avoiding duplicates)
    registry = {
        "VEC": set(),
        "LIST": set(),
        "MAP": set()
    }
    
    print(f"Scanning {root_dir}...")

    for dirpath, _, filenames in os.walk(root_dir):
        for fname in filenames:
            if fname.endswith((".c", ".h")):
                path = os.path.join(dirpath, fname)
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        
                        # Find Vectors
                        for match in REGEX_VEC.findall(content):
                            # match = (Type, Name)
                            registry["VEC"].add(match)

                        # Find Lists
                        for match in REGEX_LIST.findall(content):
                            # match = (Type, Name)
                            registry["LIST"].add(match)

                        # Find Maps
                        for match in REGEX_MAP.findall(content):
                            # match = (Key, Val, Name)
                            registry["MAP"].add(match)
                            
                except Exception as e:
                    print(f"Skipping {fname}: {e}")

    return registry

def generate_header(registry, output_file):
    print(f"Generating {output_file}...")

    output_dir = os.path.dirname(output_file)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("/* AUTO-GENERATED BY Z-SCANNER - DO NOT EDIT */\n")
        f.write("#ifndef Z_REGISTRY_H\n")
        f.write("#define Z_REGISTRY_H\n\n")

        # VECTORS
        f.write("/* Vectors */\n")
        f.write("#define Z_AUTOGEN_VECS(X) \\\n")
        for type_t, name in sorted(registry["VEC"], key=lambda x: x[1]):
            f.write(f"    X({type_t.strip()}, {name}) \\\n")
        f.write("\n")

        # LISTS
        f.write("/* Lists */\n")
        f.write("#define Z_AUTOGEN_LISTS(X) \\\n")
        for type_t, name in sorted(registry["LIST"], key=lambda x: x[1]):
            f.write(f"    X({type_t.strip()}, {name}) \\\n")
        f.write("\n")
        
        # MAPS
        f.write("/* Maps */\n")
        f.write("#define Z_AUTOGEN_MAPS(X) \\\n")
        for key_t, val_t, name in sorted(registry["MAP"], key=lambda x: x[2]):
            f.write(f"    X({key_t.strip()}, {val_t.strip()}, {name}) \\\n")
        f.write("\n")

        f.write("#endif // Z_REGISTRY_H\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Scan C files for z-lib type definitions.")
    parser.add_argument("src", help="Source directory to scan")
    parser.add_argument("out", help="Output header file (e.g., z_registry.h)")
    
    args = parser.parse_args()
    
    reg = scan_directory(args.src)
    generate_header(reg, args.out)
    print("Done.")
